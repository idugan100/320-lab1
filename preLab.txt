Bubble Sort: repeatedly swaps adjacent elements if they are in the wrong order. O(n^2)

Selection Sort: repeatedly searches the array for the smallest element and swaps it with the
    lowest index unsorted element. O(n^2)

Insertion Sort: assumes first element is sorted and then places the first unsorted element in it's sorted
    location relative to the sorted element. O(n^2)

Merge Sort: Recursivley split the array until each sub array had zero or one elements. The combine the 
    sub-arrays in sorted order. O(nlog(n))

Quick Sort: Select a central elemnt to partition and swap elements on either side until it is in the 
    correct location. 0(nlog(n))

Radix Sort: assumes data is in a specified range and map the data to a count array. The count array gives
    the position of each element. O(n).


Question 1: The algorithm ends when it has found the max and minimum and swapped them to their correct 
    locations n/2 times when n is even and (n-1)/2 times when n is odd because the element in the 
    middle will be in the correct location even though it hasn't been selected as a min or max.

Question 2: Selection sort can be bounded by big theta(n^2/2) because it has to iterate over each location to 
    find the minimum, but each iteration to find the current minimumin  in only n-i iterations where i 
    is the index of the first unsorted element. Double ended selection sort can be bounded by big theta 
    (n^2/4) because it take only n-2i iterations to find the current minimum where i is the index of the 
    first unsorted element.